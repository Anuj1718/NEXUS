//i can add id, class and style, etc also in react element
const element = React.createElement("h1",{id:"first", className:"Rahul", style:{backgroundColor:"blue", fontSize:"30px", color:"pink"}},"Hello Coder Army");
const element2 = React.createElement("h2",{id:"second", className:"Rahul", style:{backgroundColor:"black", fontSize:"30px", color:"pink"}},"Maja aaya muje");
// ReactDOM.render(element,document.getElementById('root'));
// element : 50 card pade hue hai
const div1 = React.createElement('div',{},[element,element2]);
const Reactroot = ReactDOM.createRoot(document.getElementById('root'));
// React root container: is
// Reactroot.render(element);
// Reactroot.render(element2);
//whenever i render something new the previous one gets replaced, jo previous data tha wo chala jata hai aur new data aa jata hai i.e jo previous render hua tha ya previously jo index.html me tha wo chala jata hai aur new data aa jata hai
//i want both the elements to be rendered
//so for that we have to wrap both the elements in a single parent element i.e a div
Reactroot.render(div1);


// {/* <div>
//     <h1>Hello Coder Army</h1>
//     <h2>Maja aaya muje</h2>
// </div> */}

// what if i want like this

{/* <div>
    <div>
        <h1>
            <p>
                
            </p>
        </h1>
    </div>
</div> */}
// const div2 = React.createElement('div',{},React.createElement('div',{},React.createElement('h1',{},React.createElement('p',{}))));
// Reactroot.render(div2);

//what if i wanna write html code in js/react file itself
// we can use JSX for that
//JSX: Javascript XML
//JSX allows us to write HTML in React
//JSX makes it easier to write and add HTML in React
//jsx says tum bindaas js ka code likho aur usme html bhi likh do, badme jsx usko react mai convert kar dega aur usko html me convert kar dega

//earlier people used to write react code without jsx
//i.e using React.createElement() method
//but now a days everyone uses jsx to write react code
//jsx is not mandatory to write react code but it is recommended to use jsx to write react code
//jsx makes it easier to write and understand react code
//jsx is not html, it is a syntax extension of javascript
//under the hood jsx gets converted to react.createElement() method calls
//browsers do not understand jsx, so we need to use a transpiler like babel to convert jsx to react.createElement() method calls
//babel is a javascript compiler that converts jsx to react.createElement() method calls
//babel is used in create-react-app by default
//so whenever we write jsx in our react code, babel converts it to react.createElement() method calls before rendering it to the browser

//is our code production ready?
//the two scripts we are using in index.html are from cdn and they are development versions of react and react-dom
//we should use production versions of react and react-dom in production
//production versions are minified and optimized for performance
//development versions have extra warnings and checks for development purposes
//in real world projects we use bundlers like webpack, parcel, etc to bundle our code and they take care of using production versions in production builds
//those two network calls in index.html will take time to load and will slow down our app
//should we paste their code in our index.html?
//no, because they are huge files and will bloat our index.html file
//we should use a package manager like npm or yarn to install react and react-dom packages in our project
//then we can import them in our js files
//this way we can manage their versions and update them easily
//in real world projects we use create-react-app or other boilerplates that set up the project structure and configurations for us
//i want optimized code: no comments, no warnings, no extra checks, in those react and react-dom files, there must be some extra code for development purposes which we are not using in our app
//so we use production versions of react and react-dom in production builds
//in create-react-app this is taken care of automatically when we run npm run build
//it creates a build folder with optimized production ready code

//answer by rohit negi:
//we use bundlers like webpack, parcel, etc in real world projects to bundle our code and manage dependencies
//these bundlers take care of using production versions of react and react-dom in production builds
//they also optimize our code by minifying and removing unused code
//this way we get optimized production ready code without any extra effort
//bundlers optimize the code for better performance and smaller bundle size by removing unnecessary code and comments, only taking the code from react and react-dom that is actually needed for our app to run
//it reads all the import statements in our code and includes only the necessary parts of react and react-dom in the final bundle

//eg of bundlers: webpack, vite, parcel, rollup, etc
//bundlers are present in create-react-app by default 
//so we don't have to set up bundlers manually in create-react-app
// they come pre-configured with create-react-app

//misconceptions about react:
//people think react optimizes the code but actually bundlers optimize the code
//react is just a library for building user interfaces
//it does not handle code optimization or bundling
//those tasks are handled by bundlers
//people also think that react and react-dom are the same but they are different
//react is the core library for building user interfaces
//react-dom is a package that provides DOM-specific methods for rendering react components to the DOM
//in react-native we use react-native-dom instead of react-dom for rendering react components to native mobile platforms
//people also think that in react, we can write html code directly in js files but actually we use jsx which is a syntax extension of javascript that allows us to write html-like code in js files
//under the hood jsx gets converted to react.createElement() method calls by babel
//browsers do not understand jsx, so we need to use a transpiler like babel to convert jsx to react.createElement() method calls

//we will use parcel as our bundler in this course
//parcel is a zero-configuration bundler that works out of the box
//it supports jsx and other modern javascript features by default
//to use parcel we need to install it globally using npm or yarn
//then we can run parcel index.html to start the development server
//parcel will automatically bundle our code and serve it to the browser
//it also supports hot module replacement (HMR) which means that when we make changes to our code, the changes will be reflected in the browser without a full page reload

//write
//npm init or npm init -y (package.json file banane ke liye)
//The -y flag automatically says "yes" to all questions and creates a default package.json. This is the fastest way when you're just learning and don't need to customize the package.json settings.
//npm install parcel or npm i parcel -D (to install parcel bundler, nodemodules folder banane ke liye)
//D saves the package as a devDependency instead of a regular dependency.

// devDependencies are packages needed only during development (like bundlers, testing tools, linters), not in production when your app runs.

// dependencies are packages your app needs to actually run (like react, react-dom).

// When you use npm install parcel -D, it adds parcel to the devDependencies section of your package.json because parcel is only needed to bundle your code during development, not when your app is deployed.

// Equivalent commands:

// npm install parcel -D
// npm install parcel --save-dev
// Both do the same thing.
//npx parcel index.html
//parcel will start a development server and open the app in the browser
//it will also watch for changes in our code and automatically reload the app in the browser

//what is npm?
//npm: node package manager
//it is a package manager for javascript
//it allows us to install and manage packages (libraries, frameworks, tools, etc) in our projects
//it also allows us to manage dependencies and scripts in our projects
//it comes pre-installed with node.js
//we can use npm to install react and react-dom packages in our project
//then we can import them in our js files
//this way we can manage their versions and update them easily

//npmjs.com is the official website for npm
//we can search for packages and read their documentation on npmjs.com
//we can also publish our own packages on npmjs.com

//we can also contribute to open source packages on npmjs.com like say digitalclock, calendar if u made great
//open source packages are packages that are publicly available for anyone to use and contribute to
//we can fork a package, make changes, and submit a pull request to the original package repository
//if the changes are accepted, they will be merged into the original package and will be available for everyone to use

//whoever created parcel didnt do it from scratch, they must have used some existing libraries and tools to create parcel
// hence, when we install parcel, it also installs all the dependencies that parcel needs to work
//these dependencies are listed in the package.json file of parcel
//when we install parcel, npm reads the package.json file of parcel and installs all the dependencies listed in it
//this way parcel can work properly without us having to install each dependency manually
//node_modules folder is created to store all the installed packages and their dependencies
//if we installed parcel, why others came in node_modules folder?
//because parcel has its own dependencies that it needs to work

//similarly, when we install react and react-dom, npm installs all the dependencies that react and react-dom need to work
//this is one of the main advantages of using a package manager like npm
//it takes care of managing dependencies for us

//vite vs parcel
//both are bundlers
//vite is faster than parcel
//vite uses esbuild for bundling which is written in go and is faster than javascript based bundlers like parcel
//vite has better support for modern javascript features like es modules, dynamic imports, etc
//parcel is easier to use and has better support for legacy javascript features like commonjs, amd, etc
//parcel has better support for non-javascript assets like css, images, etc
//both are good bundlers and we can use either of them based on our requirements

//no need to write script src for react and react-dom in index.html when using bundlers like parcel or vite
//npm install react
//npm install react-dom
//this wills install react and react-dom packages in our project in node_modules folder and add them to package.json dependencies
//dependeincies are the packages that our project needs to run
//dependencies are listed in package.json file (parcel and react and react-dom will be listed there now along with their versions)
//react 19 is latest version as of june 2024
//then we can import them in our js files
//import React from 'react';
//import ReactDOM from 'react-dom/client';

//npm install react is preffered over using script src in index.html because
//1. we can manage versions of react and react-dom easily
//2. we can use other packages and libraries easily
//3. we can use bundlers like parcel or vite to bundle our code and optimize it for production
//4. we can use modern javascript features like es modules, dynamic imports, etc easily
//5. we can use non-javascript assets like css, images, etc easily
// and it downloads the latest version of react and react-dom available unlike cdn where we have to manually change the version in script src 

//package.json file keeps track of all the packages and their versions that are installed in our project
//it also keeps track of scripts that we can run in our project
//scripts are commands that we can run in our project using npm
//eg: "start": "parcel index.html" (to start the development server)
//"build": "parcel build index.html" (to create a production build)
//we can run these scripts using npm run start or npm run build

//whenever we share our project with someone else, we don't need to share node_modules folder
//we just need to share package.json and package-lock.json files
//the other person can run npm install to install all the dependencies listed in package.json file
//npm install reads package.json file and installs all the dependencies listed in it in node_modules folder

// package-lock.json file keeps track of the exact versions of the packages that are installed in our project
//it ensures that everyone who installs the dependencies gets the same versions of the packages
//this is important to avoid compatibility issues between different versions of packages

//whenever we install a package using npm, it also installs all the dependencies that the package needs to work
//these dependencies are listed in the package.json file of the package
//npm reads the package.json file of the package and installs all the dependencies listed in it
//this way the package can work properly without us having to install each dependency manually
//node_modules folder is created to store all the installed packages and their dependencies

//^ (caret symbol) is used in package.json to specify that we want to install the latest minor and patch versions of a package
//eg: "react": "^19.0.0" means we want to install the latest version of react that is compatible with 19.0.0
//so if 19.1.0 or 19.0.1 is released, npm will install that version instead of 19.0.0
//~ (tilde symbol) is used in package.json to specify that we want to install the latest patch version of a package
//eg: "react": "~19.0.0" means we want to install the latest patch version of react that is compatible with 19.0.0
//so if 19.0.1 is released, npm will install that version instead of 19.0.0 but it will not install 19.1.0
//no symbol means we want to install the exact version of a package
//eg: "react": "19.0.0" means we want to install exactly version 19.0.0 of react
//so if 19.0.1 or 19.1.0 is released, npm will still install version 19.0.0


// version 18.2.3 means major version 18, minor version 2, patch version 3


//eg of versioning:
// version: 18.2.3
// function sum(a,b){
//     return a+b;
// }

// sum(2,3);


//version: 18.3.0
// function sum(a,b){
//     return a+b;
// }

// function subtract(a,b){
//     return a-b;
// }
//sum(2,3); //code fatega nai

// version: 19.0.0
// function sum(a,b,c){
//     return a+b+c;
// }

// function subtract(a,b){
//     return a-b;
// }
//sum(2,3); code fatega
// sum(2,3,0);



//we dont share node_modules folder because it is huge in size (300mb)and can be easily recreated using package.json and package-lock.json files
//dont upload node_modules folder to github or any version control system
//just by running npm install, all the dependencies will be installed in node_modules folder again, it goes to package-lock.json file, reads all the dependencies and their versions and installs them in node_modules folder
//if package-lock.json file is not present, it reads package.json file and installs the dependencies but the versions may vary
//hence package-lock.json file is important to ensure that everyone gets the same versions of the packages

//how to get pakcage-lock.json file?
//it is automatically created when we run npm install command
//if package-lock.json file is deleted, it will be recreated when we run npm install command again

//package-lock.json file should be committed to version control system like github
//so that everyone gets the same versions of the packages when they install the dependencies

//package-lock.json file should not be manually edited
//it is automatically managed by npm
//if we manually edit it, it may cause issues when installing dependencies

//in real world projects, package.json and package-lock.json files are very important
//they help in managing dependencies and ensuring that everyone gets the same versions of the packages
//they also help in recreating the project environment easily on different machines

//how is package-lock.json created the first time?
//when we run npm install react for the first time, npm creates package.json file if it is not already present
//then it installs react package and its dependencies in node_modules folder
//it also creates package-lock.json file to keep track of the exact versions of the packages that are installed
//this way package-lock.json file is created the first time when we install a package using npm install command

//does npm init create package-lock.json file?
//no, npm init only creates package.json file
//package-lock.json file is created when we run npm install command for the first time

//how to update packages to their latest versions?
//we can use npm update command to update all the packages to their latest versions based on the versioning rules specified in package.json file
//we can also use npm install <package-name>@latest to update a specific package to its latest version
//after updating the packages, package-lock.json file is also updated to reflect the new versions of the packages

//always test the app after updating packages to ensure that everything is working fine
//sometimes updating packages may cause compatibility issues or break existing functionality
//so it is important to test the app thoroughly after updating packages

